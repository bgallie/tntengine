// Package tntEngine - define TntEngine type and it's methods
package tntEngine

import "math/bits"

var blk CypherBlock

type Rand struct {
	tntMachine *TntEngine
}

func New(src *TntEngine) *Rand {
	var rand Rand
	rand.tntMachine = src
	blk.Length = 0
	return &rand
}

func (rnd *Rand) Intn(max int) int {
	left := rnd.tntMachine.left
	right := rnd.tntMachine.right
	if blk.Length == 0 {
		blk.Length = CypherBlockBytes
		blkSlice := blk.CypherBlock[:]
		copy(blkSlice, rnd.tntMachine.jc1Key.XORKeyStream(blkSlice))
	}
	for {
		if max <= 0 {
			panic("argument to intn is <= 0")
		}

		n := max - 1
		// bitLen is the maximum bit length needed to encode a value < max.
		bitLen := bits.Len(uint(n))
		if bitLen == 0 {
			// the only valid result is 0
			return n
		}
		// k is the maximum byte length needed to encode a value < max.
		k := (bitLen + 7) / 8
		// b is the number of bits in the most significant byte of max-1.
		b := uint(bitLen % 8)
		if b == 0 {
			b = 8
		}

		bytes := make([]byte, k)

		for {
			// If there are not enough bytes in 'blk' to get 'k' bytes, get
			// the next 32 psudo-random bytes into 'blk'
			if blk.Length+int8(k) > 31 {
				blk.Length = CypherBlockBytes
				left <- blk
				blk = <-right
				blk.Length = 0
			}
			// Get the next 'k' psudo-random bytes generated by the TNT2
			// encryption machine.
			copy(bytes[0:], blk.CypherBlock[blk.Length:blk.Length+int8(k)])
			blk.Length += int8(k)

			// Clear bits in the first byte to increase the probability
			// that the candidate is < max.
			bytes[0] &= uint8(int(1<<b) - 1)

			// Change the data in the byte slice into an integer ('n')
			n = 0
			for _, val := range bytes {
				n = (n << 8) | int(val)
			}

			if n < max {
				return n
			}
		}
	}
}

func (rnd *Rand) Perm(n int) []int {
	res := make([]int, n, n)

	for i := range res {
		res[i] = i
	}

	for i := (n - 1); i > 0; i-- {
		j := rnd.Intn(i)
		res[i], res[j] = res[j], res[i]
	}

	return res
}
