// Package tntEngine - define TntEngine type and it's methods
package tntEngine

import (
	"math/bits"
)

var blk CypherBlock

type Rand struct {
	tntMachine *TntEngine
}

func NewRand(src *TntEngine) *Rand {
	var rand Rand
	rand.tntMachine = src
	blk.Length = 0
	return &rand
}

func (rnd *Rand) Intn(max int) int {
	if max <= 0 {
		panic("argument to intn is <= 0")
	}

	n := max - 1
	// bitLen is the maximum bit length needed to encode a value < max.
	bitLen := bits.Len(uint(n))
	if bitLen == 0 {
		// the only valid result is 0
		return n
	}
	// k is the maximum byte length needed to encode a value < max.
	k := (bitLen + 7) / 8
	// b is the number of bits in the most significant byte of max-1.
	b := uint(bitLen % 8)
	if b == 0 {
		b = 8
	}

	bytes := make([]byte, k)

	for {
		_, _ = rnd.fillBytes(bytes)
		// Clear bits in the first byte to increase the probability
		// that the candidate is < max.
		bytes[0] &= uint8(int(1<<b) - 1)

		// Change the data in the byte slice into an integer ('n')
		n = 0
		for _, val := range bytes {
			n = (n << 8) | int(val)
		}

		if n < max {
			return n
		}
	}
}

func (rnd *Rand) Perm(n int) []int {
	res := make([]int, n, n)

	for i := range res {
		res[i] = i
	}

	for i := (n - 1); i > 0; i-- {
		j := rnd.Intn(i)
		res[i], res[j] = res[j], res[i]
	}

	return res
}

func (rnd *Rand) Read(p []byte) (n int, err error) {
	return rnd.fillBytes(p)
}

func (rnd *Rand) fillBytes(p []byte) (n int, err error) {
	err = nil
	p = p[:0]
	left := rnd.tntMachine.Left()
	right := rnd.tntMachine.Right()

	// If the number of bytes to read is less then CypherBlockBytes, we will
	// attempt to fill the request from the previously retreived CypherBlock
	if cap(p) < CypherBlockBytes/2 {
		if blk.Length == 0 {
			blk.Length = CypherBlockBytes
			blkSlice := blk.CypherBlock[:]
			copy(blkSlice, rnd.tntMachine.Key().XORKeyStream(blkSlice))
			left <- blk
			blk = <-right
			blk.Length = 0
		}
		for {
			// If there are not enough bytes in 'blk' to get 'k' bytes, get
			// the next 32 psudo-random bytes into 'blk'
			if blk.Length+int8(len(p)) > 31 {
				blk.Length = CypherBlockBytes
				left <- blk
				blk = <-right
				blk.Length = 0
			}
			// Get the next 'k' psudo-random bytes generated by the TNT2
			// encryption machine.
			p = append(p, blk.CypherBlock[blk.Length:blk.Length+int8(cap(p))]...)
			blk.Length += int8(cap(p))
		}
	} else {
		for {
			blk.Length = CypherBlockBytes
			left <- blk
			blk = <-right
			remaining := cap(p) - len(p)
			if remaining >= int(blk.Length) {
				p = append(p, blk.CypherBlock[0:]...)
			} else {
				p = append(p, blk.CypherBlock[0:remaining]...)
				blk.Length = 0
				break
			}
		}
	}

	return len(p), err
}
