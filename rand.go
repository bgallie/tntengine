// This is free and unencumbered software released into the public domain.
// See the UNLICENSE file for details.

package tntengine

// Define the random number generator using tntengine as the source.

import (
	"encoding/hex"
	"fmt"
	"math/bits"
	"os"
	"reflect"
)

var emptyBlk CipherBlock

type Rand struct {
	tntMachine *TntEngine
	idx        int
	blk        CipherBlock
}

// NewRand [deprecated] returns a Rand object.
func NewRand(src *TntEngine) *Rand {
	fmt.Fprintln(os.Stderr, "WARNING: rand.NewRand() is deprecated.  Use Rand.New() instead")
	return new(Rand).New(src)
}

// New returns a Rand object.
func (rnd *Rand) New(src *TntEngine) *Rand {
	rnd.tntMachine = src
	rnd.idx = CipherBlockBytes
	return rnd
}

// Intn returns, as an int, a non-negative pseudo-random number in the
// half-open interval [0,n) from the tntengine. It panics if n <= 0.
func (rnd *Rand) Intn(max int) int {
	if max <= 0 {
		panic("argument to Intn is <= 0")
	}
	return int(rnd.Int63n(int64(max)))
}

// Int15n returns, as an int16, a non-negative pseudo-random number in the
// half-open interval [0,n). It panics if n <= 0.
func (rnd *Rand) Int15n(max int16) int16 {
	if max <= 0 {
		panic("argument to Int15n is <= 0")
	}
	return int16(rnd.Int63n(int64(max)))
}

// Int31n returns, as an int32, a non-negative pseudo-random number in the
// half-open interval [0,n). It panics if n <= 0.
func (rnd *Rand) Int31n(max int32) int32 {
	if max <= 0 {
		panic("argument to Int31n is <= 0")
	}
	return int32(rnd.Int63n(int64(max)))
}

// Int63n returns, as an int64, a non-negative pseudo-random number in the
// half-open interval [0,n). It panics if n <= 0.
func (rnd *Rand) Int63n(max int64) int64 {
	if max <= 0 {
		panic("argument to Int63n is <= 0")
	}

	n := max - 1
	// bitLen is the maximum bit length needed to encode a value < max.
	bitLen := bits.Len64(uint64(n))
	if bitLen == 0 {
		// the only valid result is 0
		return n
	}
	// k is the maximum byte length needed to encode a value < max.
	k := (bitLen + 7) / 8
	// b is the number of bits in the most significant byte of max-1.
	b := uint(bitLen % 8)
	if b == 0 {
		b = 8
	}

	bytes := make([]byte, k)

	for {
		_, _ = rnd.Read(bytes)
		// Clear bits in the first byte to increase the probability
		// that the candidate is < max.
		bytes[0] &= uint8(int(1<<b) - 1)

		// Change the data in the byte slice into an integer ('n')
		n = 0
		for _, val := range bytes {
			n = (n << 8) | int64(val)
		}

		if n < max {
			return n
		}
	}
}

func (rnd *Rand) Perm(n int) []int {
	res := make([]int, n)

	for i := range res {
		res[i] = i
	}

	for i := (n - 1); i > 0; i-- {
		j := rnd.Intn(i)
		res[i], res[j] = res[j], res[i]
	}

	return res
}

func (rnd *Rand) Read(p []byte) (n int, err error) {
	err = nil
	// On the first call to Read(), initialize rnd.blk with 32 psudo-random
	// bytes that are based on the secret key so that the same sequence
	// will be generated.
	if reflect.DeepEqual(rnd.blk, emptyBlk) {
		cntrKeyBytes, _ := hex.DecodeString(rnd.tntMachine.cntrKey)
		cntrKeyBytes = jc1Key.XORKeyStream(cntrKeyBytes)
		rnd.blk = make(CipherBlock, CipherBlockBytes)
		_ = copy(rnd.blk[:], cntrKeyBytes)
	}
	// Clear out p to receive the psudo random data.
	p = p[:0]
	// Read psudo-random data generated by the tntengine (32 bytes at a time)
	// and appending them into p.  It reads as many 32 bytes blocks as needed
	// to fill p.  If not all bytes in the 32 byte block are needed, then the
	// extra bytes are saved for the next ca;; to Read()
	left := rnd.tntMachine.Left()
	right := rnd.tntMachine.Right()
	for {
		if rnd.idx >= CipherBlockBytes { // No more data in rnd.blk, so get more
			left <- rnd.blk
			rnd.blk = <-right
			rnd.idx = 0
		}
		leftInBlk := len(rnd.blk) - rnd.idx // calculate how many bytes are left in rnd.blk
		remaining := cap(p) - len(p)        // calculate how many bytes are still needed to fill p.
		if remaining >= leftInBlk {         // there is enough room to all the bytes in rnd.blk
			p = append(p, rnd.blk[rnd.idx:]...) // so append all of the bytes into p.
			rnd.idx += leftInBlk
		} else { // append only the nneded bytes into p.
			p = append(p, rnd.blk[rnd.idx:rnd.idx+remaining]...)
			rnd.idx += remaining
			break
		}
		// and repeat until p is filled.
	}

	return len(p), err
}
