// Package cryptors - define TntEngine type and it's methods
package tntEngine

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"math/bits"
	"os"
	"strings"

	"github.com/bgallie/jc1"
)

var (
	counter         *Counter = new(Counter)
	proFormaMachine []Crypter
	rotorSizes      []int
	rotorSizesIndex int
	cycleSizes      []int
	cycleSizesIndex int
	proFormaFile    os.File
	perm            func(int) []int
	intn            func(int) int
	jc1Key          *jc1.UberJc1
)

type TntEngine struct {
	engineType  string // "Encrypt" or "Decrypt"
	engine      []Crypter
	left, right chan CypherBlock
	cntrKey     string
}

func (e *TntEngine) Left() chan CypherBlock {
	return e.left
}

func (e *TntEngine) Right() chan CypherBlock {
	return e.right
}

func (e *TntEngine) CounterKey() string {
	return e.cntrKey
}

func (e *TntEngine) Index() (cntr *big.Int) {
	if len(e.engine) != 0 {
		machine := e.engine[len(e.engine)-1]
		switch machine.(type) {
		default:
			cntr = BigZero
		case *Counter:
			cntr = machine.Index()
		}
	}

	return
}

func (e *TntEngine) SetIndex(iCnt *big.Int) {
	for _, machine := range e.engine {
		machine.SetIndex(iCnt)
	}
}

func (e *TntEngine) SetEngineType(engineType string) {
	switch string(strings.TrimSpace(engineType)[0]) {
	case "d", "D":
		e.engineType = "D"
	case "e", "E":
		e.engineType = "E"
	default:
		log.Fatalf("Missing or incorrect TntEngine engineType: [%s]", engineType)
	}
}

func (e *TntEngine) EngineType() string {
	return e.engineType
}

func (e *TntEngine) Init(secret []byte, proFormaFileName string) {
	jc1Key = jc1.NewUberJc1(secret)
	// Create an ecryption machine based on the proForma rotors and permutators.
	proFormaMachine = *createProFormaMachine(proFormaFileName)
	leftMost, rightMost := CreateEncryptMachine(proFormaMachine...)
	// Create a random number function [func(max int) int] that uses psudo-
	// random data generated the proforma encryption machine.
	intn, perm = createRandomNumberFunctions(leftMost, rightMost)
	// Get a 'checksum' of the encryption key.  This is used as a key to store
	// the count of blocks already encrypted to use as a starting point for the
	// next encryption.
	var blk CypherBlock
	var cksum [CypherBlockBytes]byte
	blk.Length = CypherBlockBytes
	_ = copy(blk.CypherBlock[:], jc1Key.XORKeyStream(cksum[:]))
	leftMost <- blk
	blk = <-rightMost
	e.cntrKey = hex.EncodeToString(blk.CypherBlock[:])
	// Create a permutaion of the rotor indices to allow picking the rotors in
	// a random order based on the key.
	rotorSizes = perm(len(RotorSizes))
	// Create a permutaion of cycle sizes indices to allow picking the cycle
	// sizes in a random order based on the key.
	cycleSizes = perm(len(CycleSizes))
	// Update the rotors and permutators in a very non-linear fashion.
	for pfCnt, machine := range proFormaMachine {
		switch v := machine.(type) {
		default:
			fmt.Fprintf(os.Stderr, "Unknown machine: %v\n", v)
		case *Rotor:
			updateRotor(machine.(*Rotor), leftMost, rightMost)
		case *Permutator:
			p := new(Permutator)
			updatePermutator(p, leftMost, rightMost)
			proFormaMachine[pfCnt] = p
		case *Counter:
			machine.(*Counter).SetIndex(BigZero)
		}
	}
	// Now that we have created the new rotors and permutators from the proform
	// machine, populate the TntEngine with them.
	e.engine = make([]Crypter, 9, 9)
	machineOrder := perm(len(proFormaMachine))
	// log.Println(machineOrder)
	for idx, val := range machineOrder {
		e.engine[idx] = proFormaMachine[val]
	}
	e.engine[len(e.engine)-1] = counter
}

func (e *TntEngine) BuildCipherMachine() {
	switch e.engineType {
	case "D":
		e.left, e.right = CreateDecryptMachine(e.engine...)
	case "E":
		e.left, e.right = CreateEncryptMachine(e.engine...)
	default:
		log.Fatalf("Missing or incorrect TntEngine engineType: [%s]", e.engineType)

	}
}

/*
	createRandomNumberFunctions returns two function:
	    1:	intn func(max int) int
				that will return a uniform random value in the range of
				0..(max-1) using pseudo-random bytes generated by the TNT2
				encryption algorithm. It panics if max <= 0.
		2:	perm func(n int) []int
				that will return an integer slice containing the intergers
				 0..(n-1) in a random order.

	'left' is the input channel and 'right' is the output channel for the TNT2
	encryption machine.
*/
func createRandomNumberFunctions(left chan CypherBlock, right chan CypherBlock) (func(int) int, func(n int) []int) {
	/*
		'blk' contains the data that is encrypted and is initializd to data
		generated from the uberJc1 algorithm based on the secret key enterd
		by the user.
	*/
	var blk CypherBlock
	blk.Length = CypherBlockBytes
	blkSlice := blk.CypherBlock[:]
	copy(blkSlice, jc1Key.XORKeyStream(blkSlice))

	intn := func(max int) int {
		for {
			if max <= 0 {
				panic("argument to intn is <= 0")
			}

			n := max - 1
			// bitLen is the maximum bit length needed to encode a value < max.
			bitLen := bits.Len(uint(n))
			if bitLen == 0 {
				// the only valid result is 0
				return n
			}
			// k is the maximum byte length needed to encode a value < max.
			k := (bitLen + 7) / 8
			// b is the number of bits in the most significant byte of max-1.
			b := uint(bitLen % 8)
			if b == 0 {
				b = 8
			}

			bytes := make([]byte, k)

			for {
				// If there are not enough bytes in 'blk' to get 'k' bytes, get
				// the next 32 psudo-random bytes into 'blk'
				if blk.Length+int8(k) > 31 {
					blk.Length = CypherBlockBytes
					left <- blk
					blk = <-right
					blk.Length = 0
				}
				// Get the next 'k' psudo-random bytes generated by the TNT2
				// encryption machine.
				copy(bytes[0:], blk.CypherBlock[blk.Length:blk.Length+int8(k)])
				blk.Length += int8(k)

				// Clear bits in the first byte to increase the probability
				// that the candidate is < max.
				bytes[0] &= uint8(int(1<<b) - 1)

				// Change the data in the byte slice into an integer ('n')
				n = 0
				for _, val := range bytes {
					n = (n << 8) | int(val)
				}

				if n < max {
					return n
				}
			}
		}
	}

	perm := func(n int) []int {
		res := make([]int, n, n)

		for i := range res {
			res[i] = i
		}

		for i := (n - 1); i > 0; i-- {
			j := intn(i)
			res[i], res[j] = res[j], res[i]
		}

		return res
	}

	return intn, perm
}

/*
	createProFormaMachine initializes the pro-forma machine used to create the
	TNT2 encryption machine.  If the machineFileName is not empty then the
	pro-forma machine is loaded from that file, else the hardcoded rotors and
	permutators are used to initialize the pro-formaa machine.
*/
func createProFormaMachine(machineFileName string) *[]Crypter {
	var newMachine []Crypter
	if len(machineFileName) == 0 {
		// log.Println("Using built in proforma rotors and permutators")
		// Create the proforma encryption machine.  The layout of the machine is:
		// 		rotor, rotor, permutator, rotor, rotor, permutator, rotor, rotor
		newMachine = []Crypter{
			Rotor1, Rotor2, Permutator1,
			Rotor3, Rotor4, Permutator2,
			Rotor5, Rotor6}
	} else {
		// log.Printf("Using proforma rotors and permutators from %s\n", machineFileName)
		in, err := os.Open(machineFileName)
		checkFatal(err)
		jDecoder := json.NewDecoder(in)
		// Create the proforma encryption machine from the given proforma machine file.
		// The layout of the machine is:
		// 		rotor, rotor, permutator, rotor, rotor, permutator, rotor, rotor
		var rotor1, rotor2, rotor3, rotor4, rotor5, rotor6 *Rotor
		var permutator1, permutator2 *Permutator
		newMachine = []Crypter{rotor1, rotor2, permutator1, rotor3, rotor4, permutator2, rotor5, rotor6}

		for cnt, machine := range newMachine {
			switch v := machine.(type) {
			default:
				fmt.Fprintf(os.Stderr, "Unknown machine: %v\n", v)
			case *Rotor:
				r := new(Rotor)
				err = jDecoder.Decode(&r)
				checkFatal(err)
				newMachine[cnt] = r
			case *Permutator:
				p := new(Permutator)
				err = jDecoder.Decode(&p)
				checkFatal(err)
				newMachine[cnt] = p
			}
		}
	}

	return &newMachine
}

/*
	updateRotor will update the given (proforma) rotor in place using (psudo-
	random) data generated by the TNT2 encrytption algorithm using the pro-forma
	rotors and permutators.
*/
func updateRotor(r *Rotor, left, right chan CypherBlock) {
	// Get size, start and step of the new rotor
	rotorSize := RotorSizes[rotorSizes[rotorSizesIndex]]
	rotorSizesIndex = (rotorSizesIndex + 1) % len(RotorSizes)
	start := intn(rotorSize)
	step := intn(rotorSize)

	// blkCnt is the total number of bytes needed to hold rotorSize bits + a slice of 256 bits
	blkCnt := (((rotorSize + CypherBlockSize + 7) / 8) + 31) / 32
	// blkBytes is the number of bytes rotor r needs to increase to hold the new rotor.
	blkBytes := (blkCnt * 32) - len(r.Rotor)
	// Adjust the size of r.Rotor to match the new rotor size.
	adjRotor := make([]byte, blkBytes)
	r.Rotor = append(r.Rotor, adjRotor...)
	var blk CypherBlock
	blk.Length = CypherBlockBytes
	copy(blk.CypherBlock[:], jc1Key.XORKeyStream(blk.CypherBlock[:]))
	// Fill the rotor with random data using TNT2 encryption to generate the
	// random data by encrypting the next 32 bytes of data from the uberJC1
	// algorithm until the next rotor is filled.
	for i := 0; i < blkCnt; i++ {
		left <- blk
		blk = <-right
		copy(r.Rotor[i*CypherBlockBytes:], blk.CypherBlock[:])
	}

	// update the rotor with the new size, start, and step and slice the first
	// 256 bits of the rotor to the end of the rotor.
	r.Update(rotorSize, start, step)
}

/*
	updatePermutator will update the given (proforma) permutator in place using
	(psudo-random) data generated by the TNT2 encrytption algorithm using the
	proforma rotors and permutators.
*/
func updatePermutator(p *Permutator, left, right chan CypherBlock) {
	var randp [CypherBlockSize]byte
	// Create a table of byte values [0...255] in a random order
	for i, val := range perm(CypherBlockSize) {
		randp[i] = byte(val)
	}
	// Chose a CycleSizes and randomize order of the values
	length := len(CycleSizes[cycleSizesIndex])
	cycles := make([]int, length, length)
	randi := perm(length)
	for idx, val := range randi {
		cycles[idx] = CycleSizes[cycleSizes[cycleSizesIndex]][val]
	}
	p.Update(cycles, randp[:])
	cycleSizesIndex = (cycleSizesIndex + 1) % len(CycleSizes)
}

func checkFatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
